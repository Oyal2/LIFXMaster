// @generated by protobuf-ts 2.9.4
// @generated from protobuf file "proto/message_service.proto" (package "message", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Int32Value } from "../google/protobuf/wrappers";
/**
 * Redefine the Device message to maintain the existing fields
 *
 * @generated from protobuf message message.Device
 */
export interface Device {
    /**
     * @generated from protobuf field: string address = 1;
     */
    address: string;
    /**
     * @generated from protobuf field: uint32 port = 2;
     */
    port: number;
    /**
     * @generated from protobuf field: uint64 target = 3;
     */
    target: bigint;
    /**
     * @generated from protobuf field: message.Firmware firmware = 4;
     */
    firmware?: Firmware;
    /**
     * @generated from protobuf field: message.WiFi wifi = 5;
     */
    wifi?: WiFi;
    /**
     * @generated from protobuf field: message.Power power = 6;
     */
    power?: Power;
    /**
     * @generated from protobuf field: message.Label label = 7;
     */
    label?: Label;
    /**
     * @generated from protobuf field: message.Version version = 8;
     */
    version?: Version;
    /**
     * @generated from protobuf field: message.Info info = 9;
     */
    info?: Info;
    /**
     * @generated from protobuf field: message.Product product = 10;
     */
    product?: Product;
    /**
     * @generated from protobuf field: message.Light light = 11;
     */
    light?: Light;
    /**
     * @generated from protobuf field: message.Infrared infrared = 12;
     */
    infrared?: Infrared;
    /**
     * @generated from protobuf field: message.HEV hev = 13;
     */
    hev?: HEV;
    /**
     * @generated from protobuf field: message.ExtendedColorZone extended_color_zone = 14;
     */
    extendedColorZone?: ExtendedColorZone;
    /**
     * @generated from protobuf field: message.Relay relay = 15;
     */
    relay?: Relay;
    /**
     * @generated from protobuf field: message.Tile tile = 16;
     */
    tile?: Tile;
    /**
     * @generated from protobuf field: message.Location location = 17;
     */
    location?: Location;
    /**
     * @generated from protobuf field: message.Group group = 18;
     */
    group?: Group;
}
/**
 * Define the Group message to include an array of Device
 *
 * @generated from protobuf message message.GroupMap
 */
export interface GroupMap {
    /**
     * @generated from protobuf field: repeated message.Device devices = 1;
     */
    devices: Device[];
    /**
     * @generated from protobuf field: string label = 2;
     */
    label: string;
    /**
     * @generated from protobuf field: string updated_at = 3;
     */
    updatedAt: string;
}
/**
 * Define the Location message to include an array of Group
 *
 * @generated from protobuf message message.LocationMap
 */
export interface LocationMap {
    /**
     * @generated from protobuf field: map<string, message.GroupMap> groups = 1;
     */
    groups: {
        [key: string]: GroupMap;
    };
    /**
     * @generated from protobuf field: string label = 2;
     */
    label: string;
    /**
     * @generated from protobuf field: string updated_at = 3;
     */
    updatedAt: string;
}
/**
 * @generated from protobuf message message.Group
 */
export interface Group {
    /**
     * @generated from protobuf field: string label = 1;
     */
    label: string;
    /**
     * @generated from protobuf field: string updated_at = 2;
     */
    updatedAt: string;
}
/**
 * @generated from protobuf message message.Location
 */
export interface Location {
    /**
     * @generated from protobuf field: string label = 1;
     */
    label: string;
    /**
     * @generated from protobuf field: string updated_at = 2;
     */
    updatedAt: string;
}
/**
 * @generated from protobuf message message.Firmware
 */
export interface Firmware {
    /**
     * @generated from protobuf field: uint64 build = 1;
     */
    build: bigint;
    /**
     * @generated from protobuf field: uint32 version_minor = 2;
     */
    versionMinor: number;
    /**
     * @generated from protobuf field: uint32 version_major = 3;
     */
    versionMajor: number;
}
/**
 * @generated from protobuf message message.WiFi
 */
export interface WiFi {
    /**
     * @generated from protobuf field: message.WifiInfo info = 1;
     */
    info?: WifiInfo;
    /**
     * @generated from protobuf field: message.Firmware firmware = 2;
     */
    firmware?: Firmware;
}
/**
 * @generated from protobuf message message.Power
 */
export interface Power {
    /**
     * @generated from protobuf field: uint32 level = 1;
     */
    level: number;
}
/**
 * @generated from protobuf message message.Label
 */
export interface Label {
    /**
     * @generated from protobuf field: string label = 1;
     */
    label: string;
}
/**
 * @generated from protobuf message message.Version
 */
export interface Version {
    /**
     * @generated from protobuf field: uint32 vendor = 1;
     */
    vendor: number;
    /**
     * @generated from protobuf field: uint32 product = 2;
     */
    product: number;
}
/**
 * @generated from protobuf message message.WifiInfo
 */
export interface WifiInfo {
    /**
     * @generated from protobuf field: uint32 signal = 1;
     */
    signal: number;
}
/**
 * @generated from protobuf message message.Info
 */
export interface Info {
    /**
     * @generated from protobuf field: uint64 time = 1;
     */
    time: bigint;
    /**
     * @generated from protobuf field: uint64 uptime = 2;
     */
    uptime: bigint;
    /**
     * @generated from protobuf field: uint64 downtime = 3;
     */
    downtime: bigint;
}
/**
 * @generated from protobuf message message.Product
 */
export interface Product {
    /**
     * @generated from protobuf field: uint32 pid = 1;
     */
    pid: number;
    /**
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * @generated from protobuf field: message.Features features = 3;
     */
    features?: Features;
    /**
     * @generated from protobuf field: message.Upgrade upgrades = 4;
     */
    upgrades?: Upgrade;
}
/**
 * @generated from protobuf message message.Upgrade
 */
export interface Upgrade {
    /**
     * @generated from protobuf field: uint32 major = 1;
     */
    major: number;
    /**
     * @generated from protobuf field: uint32 minor = 2;
     */
    minor: number;
    /**
     * @generated from protobuf field: message.Features features = 3;
     */
    features?: Features;
}
/**
 * @generated from protobuf message message.Features
 */
export interface Features {
    /**
     * @generated from protobuf field: bool hev = 1;
     */
    hev: boolean;
    /**
     * @generated from protobuf field: bool color = 2;
     */
    color: boolean;
    /**
     * @generated from protobuf field: bool chain = 3;
     */
    chain: boolean;
    /**
     * @generated from protobuf field: bool matrix = 4;
     */
    matrix: boolean;
    /**
     * @generated from protobuf field: bool relays = 5;
     */
    relays: boolean;
    /**
     * @generated from protobuf field: bool buttons = 6;
     */
    buttons: boolean;
    /**
     * @generated from protobuf field: bool infrared = 7;
     */
    infrared: boolean;
    /**
     * @generated from protobuf field: bool multizone = 8;
     */
    multizone: boolean;
    /**
     * @generated from protobuf field: repeated int32 temperature_range = 9;
     */
    temperatureRange: number[];
    /**
     * @generated from protobuf field: bool extended_multizone = 10;
     */
    extendedMultizone: boolean;
    /**
     * @generated from protobuf field: google.protobuf.Int32Value min_ext_mz_firmware = 11;
     */
    minExtMzFirmware?: Int32Value;
    /**
     * @generated from protobuf field: repeated int32 min_ext_mz_firmware_components = 12;
     */
    minExtMzFirmwareComponents: number[];
}
/**
 * @generated from protobuf message message.Light
 */
export interface Light {
    /**
     * @generated from protobuf field: uint32 hue = 1;
     */
    hue: number;
    /**
     * @generated from protobuf field: uint32 saturation = 2;
     */
    saturation: number;
    /**
     * @generated from protobuf field: uint32 brightness = 3;
     */
    brightness: number;
    /**
     * @generated from protobuf field: uint32 kelvin = 4;
     */
    kelvin: number;
    /**
     * @generated from protobuf field: uint32 power = 5;
     */
    power: number;
    /**
     * @generated from protobuf field: string label = 6;
     */
    label: string;
}
/**
 * @generated from protobuf message message.HSBK
 */
export interface HSBK {
    /**
     * @generated from protobuf field: uint32 hue = 1;
     */
    hue: number;
    /**
     * @generated from protobuf field: uint32 saturation = 2;
     */
    saturation: number;
    /**
     * @generated from protobuf field: uint32 brightness = 3;
     */
    brightness: number;
    /**
     * @generated from protobuf field: uint32 kelvin = 4;
     */
    kelvin: number;
}
/**
 * @generated from protobuf message message.Infrared
 */
export interface Infrared {
    /**
     * @generated from protobuf field: uint32 brightness = 1;
     */
    brightness: number;
}
/**
 * @generated from protobuf message message.HEV
 */
export interface HEV {
    /**
     * @generated from protobuf field: message.Cycle cycle = 1;
     */
    cycle?: Cycle;
    /**
     * @generated from protobuf field: message.Config config = 2;
     */
    config?: Config;
    /**
     * @generated from protobuf field: message.LastCycleResult last_cycle_result = 3;
     */
    lastCycleResult?: LastCycleResult;
}
/**
 * @generated from protobuf message message.Cycle
 */
export interface Cycle {
    /**
     * @generated from protobuf field: uint32 duration_s = 1;
     */
    durationS: number;
    /**
     * @generated from protobuf field: uint32 remaining_s = 2;
     */
    remainingS: number;
    /**
     * @generated from protobuf field: uint32 last_power = 3;
     */
    lastPower: number;
}
/**
 * @generated from protobuf message message.Config
 */
export interface Config {
    /**
     * @generated from protobuf field: bool indication = 1;
     */
    indication: boolean;
    /**
     * @generated from protobuf field: uint32 duration_s = 2;
     */
    durationS: number;
}
/**
 * @generated from protobuf message message.LastCycleResult
 */
export interface LastCycleResult {
    /**
     * @generated from protobuf field: uint32 result = 1;
     */
    result: number;
}
/**
 * @generated from protobuf message message.ExtendedColorZone
 */
export interface ExtendedColorZone {
    /**
     * @generated from protobuf field: uint32 zones_count = 1;
     */
    zonesCount: number;
    /**
     * @generated from protobuf field: uint32 zone_index = 2;
     */
    zoneIndex: number;
    /**
     * @generated from protobuf field: uint32 colors_count = 3;
     */
    colorsCount: number;
    /**
     * @generated from protobuf field: repeated message.HSBK colors = 4;
     */
    colors: HSBK[];
}
/**
 * @generated from protobuf message message.Relay
 */
export interface Relay {
    /**
     * @generated from protobuf field: message.RPower r_power = 1;
     */
    rPower?: RPower;
}
/**
 * @generated from protobuf message message.RPower
 */
export interface RPower {
    /**
     * @generated from protobuf field: uint32 relay_index = 1;
     */
    relayIndex: number;
    /**
     * @generated from protobuf field: uint32 level = 2;
     */
    level: number;
}
/**
 * @generated from protobuf message message.Tile
 */
export interface Tile {
    /**
     * @generated from protobuf field: message.DeviceChain device_chain = 1;
     */
    deviceChain?: DeviceChain;
    /**
     * @generated from protobuf field: message.Tile64 tile_64 = 2;
     */
    tile64?: Tile64;
    /**
     * @generated from protobuf field: message.TileEffect tile_effect = 3;
     */
    tileEffect?: TileEffect;
    /**
     * @generated from protobuf field: message.SensorAmbientLight sensor_ambient_light = 4;
     */
    sensorAmbientLight?: SensorAmbientLight;
}
/**
 * @generated from protobuf message message.DeviceChain
 */
export interface DeviceChain {
    /**
     * @generated from protobuf field: uint32 start_index = 1;
     */
    startIndex: number;
    /**
     * @generated from protobuf field: repeated message.TileDevices tile_devices = 2;
     */
    tileDevices: TileDevices[];
    /**
     * @generated from protobuf field: uint32 tile_devices_count = 3;
     */
    tileDevicesCount: number;
}
/**
 * @generated from protobuf message message.TileDevices
 */
export interface TileDevices {
    /**
     * @generated from protobuf field: uint32 accel_meas_x = 1;
     */
    accelMeasX: number;
    /**
     * @generated from protobuf field: uint32 accel_meas_y = 2;
     */
    accelMeasY: number;
    /**
     * @generated from protobuf field: uint32 accel_meas_z = 3;
     */
    accelMeasZ: number;
    /**
     * @generated from protobuf field: repeated uint32 reserved2 = 4;
     */
    reserved2: number[];
    /**
     * @generated from protobuf field: uint32 user_x = 5;
     */
    userX: number;
    /**
     * @generated from protobuf field: uint32 user_y = 6;
     */
    userY: number;
    /**
     * @generated from protobuf field: uint32 width = 7;
     */
    width: number;
    /**
     * @generated from protobuf field: uint32 height = 8;
     */
    height: number;
    /**
     * @generated from protobuf field: repeated uint32 reserved7 = 9;
     */
    reserved7: number[];
    /**
     * @generated from protobuf field: uint32 device_version_vendor = 10;
     */
    deviceVersionVendor: number;
    /**
     * @generated from protobuf field: uint32 device_version_product = 11;
     */
    deviceVersionProduct: number;
    /**
     * @generated from protobuf field: repeated uint32 reserved4 = 12;
     */
    reserved4: number[];
    /**
     * @generated from protobuf field: uint64 firmware_build = 13;
     */
    firmwareBuild: bigint;
    /**
     * @generated from protobuf field: repeated uint32 reserved8 = 14;
     */
    reserved8: number[];
    /**
     * @generated from protobuf field: uint32 firmware_version_minor = 15;
     */
    firmwareVersionMinor: number;
    /**
     * @generated from protobuf field: uint32 firmware_version_major = 16;
     */
    firmwareVersionMajor: number;
    /**
     * @generated from protobuf field: repeated uint32 reserved10 = 17;
     */
    reserved10: number[];
}
/**
 * @generated from protobuf message message.Tile64
 */
export interface Tile64 {
    /**
     * @generated from protobuf field: uint32 tile_index = 1;
     */
    tileIndex: number;
    /**
     * @generated from protobuf field: uint32 x = 2;
     */
    x: number;
    /**
     * @generated from protobuf field: uint32 y = 3;
     */
    y: number;
    /**
     * @generated from protobuf field: uint32 width = 4;
     */
    width: number;
    /**
     * @generated from protobuf field: repeated message.HSBK colors = 5;
     */
    colors: HSBK[];
}
/**
 * @generated from protobuf message message.TileEffect
 */
export interface TileEffect {
    /**
     * @generated from protobuf field: uint32 instanceid = 1;
     */
    instanceid: number;
    /**
     * @generated from protobuf field: uint32 type = 2;
     */
    type: number;
    /**
     * @generated from protobuf field: uint32 speed = 3;
     */
    speed: number;
    /**
     * @generated from protobuf field: uint64 duration = 4;
     */
    duration: bigint;
    /**
     * @generated from protobuf field: repeated uint32 parameters = 5;
     */
    parameters: number[];
    /**
     * @generated from protobuf field: uint32 palette_count = 6;
     */
    paletteCount: number;
    /**
     * @generated from protobuf field: repeated message.HSBK palette = 7;
     */
    palette: HSBK[];
}
/**
 * @generated from protobuf message message.SensorAmbientLight
 */
export interface SensorAmbientLight {
    /**
     * @generated from protobuf field: repeated uint32 lux = 1;
     */
    lux: number[];
}
/**
 * @generated from protobuf message message.GetDevicesRequest
 */
export interface GetDevicesRequest {
}
/**
 * @generated from protobuf message message.GetDevicesResponse
 */
export interface GetDevicesResponse {
    /**
     * @generated from protobuf field: map<string, message.LocationMap> locations = 1;
     */
    locations: {
        [key: string]: LocationMap;
    };
}
/**
 * @generated from protobuf message message.SetLocationLabelRequest
 */
export interface SetLocationLabelRequest {
    /**
     * @generated from protobuf field: string locationID = 1;
     */
    locationID: string;
    /**
     * @generated from protobuf field: string newLabel = 2;
     */
    newLabel: string;
}
/**
 * @generated from protobuf message message.SetLocationLabelResponse
 */
export interface SetLocationLabelResponse {
}
/**
 * @generated from protobuf message message.SetGroupLabelRequest
 */
export interface SetGroupLabelRequest {
    /**
     * @generated from protobuf field: string groupID = 1;
     */
    groupID: string;
    /**
     * @generated from protobuf field: string newLabel = 2;
     */
    newLabel: string;
}
/**
 * @generated from protobuf message message.SetGroupLabelResponse
 */
export interface SetGroupLabelResponse {
}
/**
 * @generated from protobuf message message.SetDeviceLabelRequest
 */
export interface SetDeviceLabelRequest {
    /**
     * @generated from protobuf field: uint64 deviceID = 1;
     */
    deviceID: bigint;
    /**
     * @generated from protobuf field: string newLabel = 2;
     */
    newLabel: string;
}
/**
 * @generated from protobuf message message.SetDeviceLabelResponse
 */
export interface SetDeviceLabelResponse {
}
/**
 * @generated from protobuf message message.SetColorRequest
 */
export interface SetColorRequest {
    /**
     * @generated from protobuf field: map<uint64, message.HSBK> colors = 1;
     */
    colors: {
        [key: string]: HSBK;
    };
}
/**
 * @generated from protobuf message message.SetColorResponse
 */
export interface SetColorResponse {
}
/**
 * @generated from protobuf message message.SetPowerRequest
 */
export interface SetPowerRequest {
    /**
     * @generated from protobuf field: map<uint64, bool> powers = 1;
     */
    powers: {
        [key: string]: boolean;
    };
}
/**
 * @generated from protobuf message message.SetPowerResponse
 */
export interface SetPowerResponse {
}
/**
 * @generated from protobuf message message.StrobeRequest
 */
export interface StrobeRequest {
    /**
     * @generated from protobuf field: repeated uint64 deviceIDs = 1;
     */
    deviceIDs: bigint[];
    /**
     * @generated from protobuf field: float speed = 2;
     */
    speed: number;
    /**
     * @generated from protobuf field: bool turnOn = 3;
     */
    turnOn: boolean;
}
/**
 * @generated from protobuf message message.StrobeResponse
 */
export interface StrobeResponse {
}
/**
 * @generated from protobuf message message.ColorCycleRequest
 */
export interface ColorCycleRequest {
    /**
     * @generated from protobuf field: repeated uint64 deviceIDs = 1;
     */
    deviceIDs: bigint[];
    /**
     * @generated from protobuf field: float speed = 2;
     */
    speed: number;
    /**
     * @generated from protobuf field: bool turnOn = 3;
     */
    turnOn: boolean;
}
/**
 * @generated from protobuf message message.ColorCycleResponse
 */
export interface ColorCycleResponse {
}
/**
 * @generated from protobuf message message.TwinkleRequest
 */
export interface TwinkleRequest {
    /**
     * @generated from protobuf field: map<uint64, message.HSBK> deviceColors = 1;
     */
    deviceColors: {
        [key: string]: HSBK;
    };
    /**
     * @generated from protobuf field: float speed = 2;
     */
    speed: number;
    /**
     * @generated from protobuf field: float intensity = 3;
     */
    intensity: number;
    /**
     * @generated from protobuf field: bool turnOn = 4;
     */
    turnOn: boolean;
}
/**
 * @generated from protobuf message message.TwinkleResponse
 */
export interface TwinkleResponse {
}
/**
 * @generated from protobuf message message.VisualizerRequest
 */
export interface VisualizerRequest {
    /**
     * @generated from protobuf field: repeated uint64 deviceIDs = 1;
     */
    deviceIDs: bigint[];
    /**
     * @generated from protobuf field: float variation = 2;
     */
    variation: number;
    /**
     * @generated from protobuf field: bool turnOn = 3;
     */
    turnOn: boolean;
}
/**
 * @generated from protobuf message message.VisualizerResponse
 */
export interface VisualizerResponse {
}
/**
 * @generated from protobuf message message.TheaterRequest
 */
export interface TheaterRequest {
    /**
     * @generated from protobuf field: repeated uint64 deviceIDs = 1;
     */
    deviceIDs: bigint[];
    /**
     * @generated from protobuf field: bool turnOn = 2;
     */
    turnOn: boolean;
    /**
     * @generated from protobuf field: int32 screen = 3;
     */
    screen: number;
}
/**
 * @generated from protobuf message message.TheaterResponse
 */
export interface TheaterResponse {
}
// @generated message type with reflection information, may provide speed optimized methods
class Device$Type extends MessageType<Device> {
    constructor() {
        super("message.Device", [
            { no: 1, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "port", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "target", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "firmware", kind: "message", T: () => Firmware },
            { no: 5, name: "wifi", kind: "message", T: () => WiFi },
            { no: 6, name: "power", kind: "message", T: () => Power },
            { no: 7, name: "label", kind: "message", T: () => Label },
            { no: 8, name: "version", kind: "message", T: () => Version },
            { no: 9, name: "info", kind: "message", T: () => Info },
            { no: 10, name: "product", kind: "message", T: () => Product },
            { no: 11, name: "light", kind: "message", T: () => Light },
            { no: 12, name: "infrared", kind: "message", T: () => Infrared },
            { no: 13, name: "hev", kind: "message", T: () => HEV },
            { no: 14, name: "extended_color_zone", kind: "message", T: () => ExtendedColorZone },
            { no: 15, name: "relay", kind: "message", T: () => Relay },
            { no: 16, name: "tile", kind: "message", T: () => Tile },
            { no: 17, name: "location", kind: "message", T: () => Location },
            { no: 18, name: "group", kind: "message", T: () => Group }
        ]);
    }
    create(value?: PartialMessage<Device>): Device {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.address = "";
        message.port = 0;
        message.target = 0n;
        if (value !== undefined)
            reflectionMergePartial<Device>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Device): Device {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string address */ 1:
                    message.address = reader.string();
                    break;
                case /* uint32 port */ 2:
                    message.port = reader.uint32();
                    break;
                case /* uint64 target */ 3:
                    message.target = reader.uint64().toBigInt();
                    break;
                case /* message.Firmware firmware */ 4:
                    message.firmware = Firmware.internalBinaryRead(reader, reader.uint32(), options, message.firmware);
                    break;
                case /* message.WiFi wifi */ 5:
                    message.wifi = WiFi.internalBinaryRead(reader, reader.uint32(), options, message.wifi);
                    break;
                case /* message.Power power */ 6:
                    message.power = Power.internalBinaryRead(reader, reader.uint32(), options, message.power);
                    break;
                case /* message.Label label */ 7:
                    message.label = Label.internalBinaryRead(reader, reader.uint32(), options, message.label);
                    break;
                case /* message.Version version */ 8:
                    message.version = Version.internalBinaryRead(reader, reader.uint32(), options, message.version);
                    break;
                case /* message.Info info */ 9:
                    message.info = Info.internalBinaryRead(reader, reader.uint32(), options, message.info);
                    break;
                case /* message.Product product */ 10:
                    message.product = Product.internalBinaryRead(reader, reader.uint32(), options, message.product);
                    break;
                case /* message.Light light */ 11:
                    message.light = Light.internalBinaryRead(reader, reader.uint32(), options, message.light);
                    break;
                case /* message.Infrared infrared */ 12:
                    message.infrared = Infrared.internalBinaryRead(reader, reader.uint32(), options, message.infrared);
                    break;
                case /* message.HEV hev */ 13:
                    message.hev = HEV.internalBinaryRead(reader, reader.uint32(), options, message.hev);
                    break;
                case /* message.ExtendedColorZone extended_color_zone */ 14:
                    message.extendedColorZone = ExtendedColorZone.internalBinaryRead(reader, reader.uint32(), options, message.extendedColorZone);
                    break;
                case /* message.Relay relay */ 15:
                    message.relay = Relay.internalBinaryRead(reader, reader.uint32(), options, message.relay);
                    break;
                case /* message.Tile tile */ 16:
                    message.tile = Tile.internalBinaryRead(reader, reader.uint32(), options, message.tile);
                    break;
                case /* message.Location location */ 17:
                    message.location = Location.internalBinaryRead(reader, reader.uint32(), options, message.location);
                    break;
                case /* message.Group group */ 18:
                    message.group = Group.internalBinaryRead(reader, reader.uint32(), options, message.group);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Device, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string address = 1; */
        if (message.address !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.address);
        /* uint32 port = 2; */
        if (message.port !== 0)
            writer.tag(2, WireType.Varint).uint32(message.port);
        /* uint64 target = 3; */
        if (message.target !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.target);
        /* message.Firmware firmware = 4; */
        if (message.firmware)
            Firmware.internalBinaryWrite(message.firmware, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* message.WiFi wifi = 5; */
        if (message.wifi)
            WiFi.internalBinaryWrite(message.wifi, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* message.Power power = 6; */
        if (message.power)
            Power.internalBinaryWrite(message.power, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* message.Label label = 7; */
        if (message.label)
            Label.internalBinaryWrite(message.label, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* message.Version version = 8; */
        if (message.version)
            Version.internalBinaryWrite(message.version, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* message.Info info = 9; */
        if (message.info)
            Info.internalBinaryWrite(message.info, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* message.Product product = 10; */
        if (message.product)
            Product.internalBinaryWrite(message.product, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* message.Light light = 11; */
        if (message.light)
            Light.internalBinaryWrite(message.light, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* message.Infrared infrared = 12; */
        if (message.infrared)
            Infrared.internalBinaryWrite(message.infrared, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* message.HEV hev = 13; */
        if (message.hev)
            HEV.internalBinaryWrite(message.hev, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* message.ExtendedColorZone extended_color_zone = 14; */
        if (message.extendedColorZone)
            ExtendedColorZone.internalBinaryWrite(message.extendedColorZone, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* message.Relay relay = 15; */
        if (message.relay)
            Relay.internalBinaryWrite(message.relay, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* message.Tile tile = 16; */
        if (message.tile)
            Tile.internalBinaryWrite(message.tile, writer.tag(16, WireType.LengthDelimited).fork(), options).join();
        /* message.Location location = 17; */
        if (message.location)
            Location.internalBinaryWrite(message.location, writer.tag(17, WireType.LengthDelimited).fork(), options).join();
        /* message.Group group = 18; */
        if (message.group)
            Group.internalBinaryWrite(message.group, writer.tag(18, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message message.Device
 */
export const Device = new Device$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GroupMap$Type extends MessageType<GroupMap> {
    constructor() {
        super("message.GroupMap", [
            { no: 1, name: "devices", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Device },
            { no: 2, name: "label", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "updated_at", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GroupMap>): GroupMap {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.devices = [];
        message.label = "";
        message.updatedAt = "";
        if (value !== undefined)
            reflectionMergePartial<GroupMap>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GroupMap): GroupMap {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated message.Device devices */ 1:
                    message.devices.push(Device.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string label */ 2:
                    message.label = reader.string();
                    break;
                case /* string updated_at */ 3:
                    message.updatedAt = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GroupMap, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated message.Device devices = 1; */
        for (let i = 0; i < message.devices.length; i++)
            Device.internalBinaryWrite(message.devices[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string label = 2; */
        if (message.label !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.label);
        /* string updated_at = 3; */
        if (message.updatedAt !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.updatedAt);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message message.GroupMap
 */
export const GroupMap = new GroupMap$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LocationMap$Type extends MessageType<LocationMap> {
    constructor() {
        super("message.LocationMap", [
            { no: 1, name: "groups", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => GroupMap } },
            { no: 2, name: "label", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "updated_at", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<LocationMap>): LocationMap {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.groups = {};
        message.label = "";
        message.updatedAt = "";
        if (value !== undefined)
            reflectionMergePartial<LocationMap>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LocationMap): LocationMap {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, message.GroupMap> groups */ 1:
                    this.binaryReadMap1(message.groups, reader, options);
                    break;
                case /* string label */ 2:
                    message.label = reader.string();
                    break;
                case /* string updated_at */ 3:
                    message.updatedAt = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: LocationMap["groups"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof LocationMap["groups"] | undefined, val: LocationMap["groups"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = GroupMap.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field message.LocationMap.groups");
            }
        }
        map[key ?? ""] = val ?? GroupMap.create();
    }
    internalBinaryWrite(message: LocationMap, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, message.GroupMap> groups = 1; */
        for (let k of globalThis.Object.keys(message.groups)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            GroupMap.internalBinaryWrite(message.groups[k], writer, options);
            writer.join().join();
        }
        /* string label = 2; */
        if (message.label !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.label);
        /* string updated_at = 3; */
        if (message.updatedAt !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.updatedAt);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message message.LocationMap
 */
export const LocationMap = new LocationMap$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Group$Type extends MessageType<Group> {
    constructor() {
        super("message.Group", [
            { no: 1, name: "label", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "updated_at", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Group>): Group {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.label = "";
        message.updatedAt = "";
        if (value !== undefined)
            reflectionMergePartial<Group>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Group): Group {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string label */ 1:
                    message.label = reader.string();
                    break;
                case /* string updated_at */ 2:
                    message.updatedAt = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Group, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string label = 1; */
        if (message.label !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.label);
        /* string updated_at = 2; */
        if (message.updatedAt !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.updatedAt);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message message.Group
 */
export const Group = new Group$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Location$Type extends MessageType<Location> {
    constructor() {
        super("message.Location", [
            { no: 1, name: "label", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "updated_at", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Location>): Location {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.label = "";
        message.updatedAt = "";
        if (value !== undefined)
            reflectionMergePartial<Location>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Location): Location {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string label */ 1:
                    message.label = reader.string();
                    break;
                case /* string updated_at */ 2:
                    message.updatedAt = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Location, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string label = 1; */
        if (message.label !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.label);
        /* string updated_at = 2; */
        if (message.updatedAt !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.updatedAt);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message message.Location
 */
export const Location = new Location$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Firmware$Type extends MessageType<Firmware> {
    constructor() {
        super("message.Firmware", [
            { no: 1, name: "build", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "version_minor", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "version_major", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<Firmware>): Firmware {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.build = 0n;
        message.versionMinor = 0;
        message.versionMajor = 0;
        if (value !== undefined)
            reflectionMergePartial<Firmware>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Firmware): Firmware {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 build */ 1:
                    message.build = reader.uint64().toBigInt();
                    break;
                case /* uint32 version_minor */ 2:
                    message.versionMinor = reader.uint32();
                    break;
                case /* uint32 version_major */ 3:
                    message.versionMajor = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Firmware, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 build = 1; */
        if (message.build !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.build);
        /* uint32 version_minor = 2; */
        if (message.versionMinor !== 0)
            writer.tag(2, WireType.Varint).uint32(message.versionMinor);
        /* uint32 version_major = 3; */
        if (message.versionMajor !== 0)
            writer.tag(3, WireType.Varint).uint32(message.versionMajor);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message message.Firmware
 */
export const Firmware = new Firmware$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WiFi$Type extends MessageType<WiFi> {
    constructor() {
        super("message.WiFi", [
            { no: 1, name: "info", kind: "message", T: () => WifiInfo },
            { no: 2, name: "firmware", kind: "message", T: () => Firmware }
        ]);
    }
    create(value?: PartialMessage<WiFi>): WiFi {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<WiFi>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WiFi): WiFi {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* message.WifiInfo info */ 1:
                    message.info = WifiInfo.internalBinaryRead(reader, reader.uint32(), options, message.info);
                    break;
                case /* message.Firmware firmware */ 2:
                    message.firmware = Firmware.internalBinaryRead(reader, reader.uint32(), options, message.firmware);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WiFi, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* message.WifiInfo info = 1; */
        if (message.info)
            WifiInfo.internalBinaryWrite(message.info, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* message.Firmware firmware = 2; */
        if (message.firmware)
            Firmware.internalBinaryWrite(message.firmware, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message message.WiFi
 */
export const WiFi = new WiFi$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Power$Type extends MessageType<Power> {
    constructor() {
        super("message.Power", [
            { no: 1, name: "level", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<Power>): Power {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.level = 0;
        if (value !== undefined)
            reflectionMergePartial<Power>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Power): Power {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 level */ 1:
                    message.level = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Power, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 level = 1; */
        if (message.level !== 0)
            writer.tag(1, WireType.Varint).uint32(message.level);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message message.Power
 */
export const Power = new Power$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Label$Type extends MessageType<Label> {
    constructor() {
        super("message.Label", [
            { no: 1, name: "label", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Label>): Label {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.label = "";
        if (value !== undefined)
            reflectionMergePartial<Label>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Label): Label {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string label */ 1:
                    message.label = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Label, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string label = 1; */
        if (message.label !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.label);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message message.Label
 */
export const Label = new Label$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Version$Type extends MessageType<Version> {
    constructor() {
        super("message.Version", [
            { no: 1, name: "vendor", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "product", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<Version>): Version {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.vendor = 0;
        message.product = 0;
        if (value !== undefined)
            reflectionMergePartial<Version>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Version): Version {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 vendor */ 1:
                    message.vendor = reader.uint32();
                    break;
                case /* uint32 product */ 2:
                    message.product = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Version, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 vendor = 1; */
        if (message.vendor !== 0)
            writer.tag(1, WireType.Varint).uint32(message.vendor);
        /* uint32 product = 2; */
        if (message.product !== 0)
            writer.tag(2, WireType.Varint).uint32(message.product);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message message.Version
 */
export const Version = new Version$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WifiInfo$Type extends MessageType<WifiInfo> {
    constructor() {
        super("message.WifiInfo", [
            { no: 1, name: "signal", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<WifiInfo>): WifiInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.signal = 0;
        if (value !== undefined)
            reflectionMergePartial<WifiInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WifiInfo): WifiInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 signal */ 1:
                    message.signal = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WifiInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 signal = 1; */
        if (message.signal !== 0)
            writer.tag(1, WireType.Varint).uint32(message.signal);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message message.WifiInfo
 */
export const WifiInfo = new WifiInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Info$Type extends MessageType<Info> {
    constructor() {
        super("message.Info", [
            { no: 1, name: "time", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "uptime", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "downtime", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Info>): Info {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.time = 0n;
        message.uptime = 0n;
        message.downtime = 0n;
        if (value !== undefined)
            reflectionMergePartial<Info>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Info): Info {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 time */ 1:
                    message.time = reader.uint64().toBigInt();
                    break;
                case /* uint64 uptime */ 2:
                    message.uptime = reader.uint64().toBigInt();
                    break;
                case /* uint64 downtime */ 3:
                    message.downtime = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Info, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 time = 1; */
        if (message.time !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.time);
        /* uint64 uptime = 2; */
        if (message.uptime !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.uptime);
        /* uint64 downtime = 3; */
        if (message.downtime !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.downtime);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message message.Info
 */
export const Info = new Info$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Product$Type extends MessageType<Product> {
    constructor() {
        super("message.Product", [
            { no: 1, name: "pid", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "features", kind: "message", T: () => Features },
            { no: 4, name: "upgrades", kind: "message", T: () => Upgrade }
        ]);
    }
    create(value?: PartialMessage<Product>): Product {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.pid = 0;
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<Product>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Product): Product {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 pid */ 1:
                    message.pid = reader.uint32();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* message.Features features */ 3:
                    message.features = Features.internalBinaryRead(reader, reader.uint32(), options, message.features);
                    break;
                case /* message.Upgrade upgrades */ 4:
                    message.upgrades = Upgrade.internalBinaryRead(reader, reader.uint32(), options, message.upgrades);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Product, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 pid = 1; */
        if (message.pid !== 0)
            writer.tag(1, WireType.Varint).uint32(message.pid);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* message.Features features = 3; */
        if (message.features)
            Features.internalBinaryWrite(message.features, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* message.Upgrade upgrades = 4; */
        if (message.upgrades)
            Upgrade.internalBinaryWrite(message.upgrades, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message message.Product
 */
export const Product = new Product$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Upgrade$Type extends MessageType<Upgrade> {
    constructor() {
        super("message.Upgrade", [
            { no: 1, name: "major", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "minor", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "features", kind: "message", T: () => Features }
        ]);
    }
    create(value?: PartialMessage<Upgrade>): Upgrade {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.major = 0;
        message.minor = 0;
        if (value !== undefined)
            reflectionMergePartial<Upgrade>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Upgrade): Upgrade {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 major */ 1:
                    message.major = reader.uint32();
                    break;
                case /* uint32 minor */ 2:
                    message.minor = reader.uint32();
                    break;
                case /* message.Features features */ 3:
                    message.features = Features.internalBinaryRead(reader, reader.uint32(), options, message.features);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Upgrade, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 major = 1; */
        if (message.major !== 0)
            writer.tag(1, WireType.Varint).uint32(message.major);
        /* uint32 minor = 2; */
        if (message.minor !== 0)
            writer.tag(2, WireType.Varint).uint32(message.minor);
        /* message.Features features = 3; */
        if (message.features)
            Features.internalBinaryWrite(message.features, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message message.Upgrade
 */
export const Upgrade = new Upgrade$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Features$Type extends MessageType<Features> {
    constructor() {
        super("message.Features", [
            { no: 1, name: "hev", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "color", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "chain", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "matrix", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "relays", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "buttons", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "infrared", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "multizone", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "temperature_range", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "extended_multizone", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "min_ext_mz_firmware", kind: "message", T: () => Int32Value },
            { no: 12, name: "min_ext_mz_firmware_components", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Features>): Features {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.hev = false;
        message.color = false;
        message.chain = false;
        message.matrix = false;
        message.relays = false;
        message.buttons = false;
        message.infrared = false;
        message.multizone = false;
        message.temperatureRange = [];
        message.extendedMultizone = false;
        message.minExtMzFirmwareComponents = [];
        if (value !== undefined)
            reflectionMergePartial<Features>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Features): Features {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool hev */ 1:
                    message.hev = reader.bool();
                    break;
                case /* bool color */ 2:
                    message.color = reader.bool();
                    break;
                case /* bool chain */ 3:
                    message.chain = reader.bool();
                    break;
                case /* bool matrix */ 4:
                    message.matrix = reader.bool();
                    break;
                case /* bool relays */ 5:
                    message.relays = reader.bool();
                    break;
                case /* bool buttons */ 6:
                    message.buttons = reader.bool();
                    break;
                case /* bool infrared */ 7:
                    message.infrared = reader.bool();
                    break;
                case /* bool multizone */ 8:
                    message.multizone = reader.bool();
                    break;
                case /* repeated int32 temperature_range */ 9:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.temperatureRange.push(reader.int32());
                    else
                        message.temperatureRange.push(reader.int32());
                    break;
                case /* bool extended_multizone */ 10:
                    message.extendedMultizone = reader.bool();
                    break;
                case /* google.protobuf.Int32Value min_ext_mz_firmware */ 11:
                    message.minExtMzFirmware = Int32Value.internalBinaryRead(reader, reader.uint32(), options, message.minExtMzFirmware);
                    break;
                case /* repeated int32 min_ext_mz_firmware_components */ 12:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.minExtMzFirmwareComponents.push(reader.int32());
                    else
                        message.minExtMzFirmwareComponents.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Features, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool hev = 1; */
        if (message.hev !== false)
            writer.tag(1, WireType.Varint).bool(message.hev);
        /* bool color = 2; */
        if (message.color !== false)
            writer.tag(2, WireType.Varint).bool(message.color);
        /* bool chain = 3; */
        if (message.chain !== false)
            writer.tag(3, WireType.Varint).bool(message.chain);
        /* bool matrix = 4; */
        if (message.matrix !== false)
            writer.tag(4, WireType.Varint).bool(message.matrix);
        /* bool relays = 5; */
        if (message.relays !== false)
            writer.tag(5, WireType.Varint).bool(message.relays);
        /* bool buttons = 6; */
        if (message.buttons !== false)
            writer.tag(6, WireType.Varint).bool(message.buttons);
        /* bool infrared = 7; */
        if (message.infrared !== false)
            writer.tag(7, WireType.Varint).bool(message.infrared);
        /* bool multizone = 8; */
        if (message.multizone !== false)
            writer.tag(8, WireType.Varint).bool(message.multizone);
        /* repeated int32 temperature_range = 9; */
        if (message.temperatureRange.length) {
            writer.tag(9, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.temperatureRange.length; i++)
                writer.int32(message.temperatureRange[i]);
            writer.join();
        }
        /* bool extended_multizone = 10; */
        if (message.extendedMultizone !== false)
            writer.tag(10, WireType.Varint).bool(message.extendedMultizone);
        /* google.protobuf.Int32Value min_ext_mz_firmware = 11; */
        if (message.minExtMzFirmware)
            Int32Value.internalBinaryWrite(message.minExtMzFirmware, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* repeated int32 min_ext_mz_firmware_components = 12; */
        if (message.minExtMzFirmwareComponents.length) {
            writer.tag(12, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.minExtMzFirmwareComponents.length; i++)
                writer.int32(message.minExtMzFirmwareComponents[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message message.Features
 */
export const Features = new Features$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Light$Type extends MessageType<Light> {
    constructor() {
        super("message.Light", [
            { no: 1, name: "hue", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "saturation", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "brightness", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "kelvin", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "power", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "label", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Light>): Light {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.hue = 0;
        message.saturation = 0;
        message.brightness = 0;
        message.kelvin = 0;
        message.power = 0;
        message.label = "";
        if (value !== undefined)
            reflectionMergePartial<Light>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Light): Light {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 hue */ 1:
                    message.hue = reader.uint32();
                    break;
                case /* uint32 saturation */ 2:
                    message.saturation = reader.uint32();
                    break;
                case /* uint32 brightness */ 3:
                    message.brightness = reader.uint32();
                    break;
                case /* uint32 kelvin */ 4:
                    message.kelvin = reader.uint32();
                    break;
                case /* uint32 power */ 5:
                    message.power = reader.uint32();
                    break;
                case /* string label */ 6:
                    message.label = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Light, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 hue = 1; */
        if (message.hue !== 0)
            writer.tag(1, WireType.Varint).uint32(message.hue);
        /* uint32 saturation = 2; */
        if (message.saturation !== 0)
            writer.tag(2, WireType.Varint).uint32(message.saturation);
        /* uint32 brightness = 3; */
        if (message.brightness !== 0)
            writer.tag(3, WireType.Varint).uint32(message.brightness);
        /* uint32 kelvin = 4; */
        if (message.kelvin !== 0)
            writer.tag(4, WireType.Varint).uint32(message.kelvin);
        /* uint32 power = 5; */
        if (message.power !== 0)
            writer.tag(5, WireType.Varint).uint32(message.power);
        /* string label = 6; */
        if (message.label !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.label);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message message.Light
 */
export const Light = new Light$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HSBK$Type extends MessageType<HSBK> {
    constructor() {
        super("message.HSBK", [
            { no: 1, name: "hue", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "saturation", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "brightness", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "kelvin", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<HSBK>): HSBK {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.hue = 0;
        message.saturation = 0;
        message.brightness = 0;
        message.kelvin = 0;
        if (value !== undefined)
            reflectionMergePartial<HSBK>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HSBK): HSBK {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 hue */ 1:
                    message.hue = reader.uint32();
                    break;
                case /* uint32 saturation */ 2:
                    message.saturation = reader.uint32();
                    break;
                case /* uint32 brightness */ 3:
                    message.brightness = reader.uint32();
                    break;
                case /* uint32 kelvin */ 4:
                    message.kelvin = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HSBK, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 hue = 1; */
        if (message.hue !== 0)
            writer.tag(1, WireType.Varint).uint32(message.hue);
        /* uint32 saturation = 2; */
        if (message.saturation !== 0)
            writer.tag(2, WireType.Varint).uint32(message.saturation);
        /* uint32 brightness = 3; */
        if (message.brightness !== 0)
            writer.tag(3, WireType.Varint).uint32(message.brightness);
        /* uint32 kelvin = 4; */
        if (message.kelvin !== 0)
            writer.tag(4, WireType.Varint).uint32(message.kelvin);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message message.HSBK
 */
export const HSBK = new HSBK$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Infrared$Type extends MessageType<Infrared> {
    constructor() {
        super("message.Infrared", [
            { no: 1, name: "brightness", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<Infrared>): Infrared {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.brightness = 0;
        if (value !== undefined)
            reflectionMergePartial<Infrared>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Infrared): Infrared {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 brightness */ 1:
                    message.brightness = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Infrared, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 brightness = 1; */
        if (message.brightness !== 0)
            writer.tag(1, WireType.Varint).uint32(message.brightness);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message message.Infrared
 */
export const Infrared = new Infrared$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HEV$Type extends MessageType<HEV> {
    constructor() {
        super("message.HEV", [
            { no: 1, name: "cycle", kind: "message", T: () => Cycle },
            { no: 2, name: "config", kind: "message", T: () => Config },
            { no: 3, name: "last_cycle_result", kind: "message", T: () => LastCycleResult }
        ]);
    }
    create(value?: PartialMessage<HEV>): HEV {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<HEV>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HEV): HEV {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* message.Cycle cycle */ 1:
                    message.cycle = Cycle.internalBinaryRead(reader, reader.uint32(), options, message.cycle);
                    break;
                case /* message.Config config */ 2:
                    message.config = Config.internalBinaryRead(reader, reader.uint32(), options, message.config);
                    break;
                case /* message.LastCycleResult last_cycle_result */ 3:
                    message.lastCycleResult = LastCycleResult.internalBinaryRead(reader, reader.uint32(), options, message.lastCycleResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HEV, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* message.Cycle cycle = 1; */
        if (message.cycle)
            Cycle.internalBinaryWrite(message.cycle, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* message.Config config = 2; */
        if (message.config)
            Config.internalBinaryWrite(message.config, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* message.LastCycleResult last_cycle_result = 3; */
        if (message.lastCycleResult)
            LastCycleResult.internalBinaryWrite(message.lastCycleResult, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message message.HEV
 */
export const HEV = new HEV$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Cycle$Type extends MessageType<Cycle> {
    constructor() {
        super("message.Cycle", [
            { no: 1, name: "duration_s", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "remaining_s", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "last_power", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<Cycle>): Cycle {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.durationS = 0;
        message.remainingS = 0;
        message.lastPower = 0;
        if (value !== undefined)
            reflectionMergePartial<Cycle>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Cycle): Cycle {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 duration_s */ 1:
                    message.durationS = reader.uint32();
                    break;
                case /* uint32 remaining_s */ 2:
                    message.remainingS = reader.uint32();
                    break;
                case /* uint32 last_power */ 3:
                    message.lastPower = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Cycle, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 duration_s = 1; */
        if (message.durationS !== 0)
            writer.tag(1, WireType.Varint).uint32(message.durationS);
        /* uint32 remaining_s = 2; */
        if (message.remainingS !== 0)
            writer.tag(2, WireType.Varint).uint32(message.remainingS);
        /* uint32 last_power = 3; */
        if (message.lastPower !== 0)
            writer.tag(3, WireType.Varint).uint32(message.lastPower);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message message.Cycle
 */
export const Cycle = new Cycle$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Config$Type extends MessageType<Config> {
    constructor() {
        super("message.Config", [
            { no: 1, name: "indication", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "duration_s", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<Config>): Config {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.indication = false;
        message.durationS = 0;
        if (value !== undefined)
            reflectionMergePartial<Config>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Config): Config {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool indication */ 1:
                    message.indication = reader.bool();
                    break;
                case /* uint32 duration_s */ 2:
                    message.durationS = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Config, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool indication = 1; */
        if (message.indication !== false)
            writer.tag(1, WireType.Varint).bool(message.indication);
        /* uint32 duration_s = 2; */
        if (message.durationS !== 0)
            writer.tag(2, WireType.Varint).uint32(message.durationS);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message message.Config
 */
export const Config = new Config$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LastCycleResult$Type extends MessageType<LastCycleResult> {
    constructor() {
        super("message.LastCycleResult", [
            { no: 1, name: "result", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<LastCycleResult>): LastCycleResult {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.result = 0;
        if (value !== undefined)
            reflectionMergePartial<LastCycleResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LastCycleResult): LastCycleResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 result */ 1:
                    message.result = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LastCycleResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 result = 1; */
        if (message.result !== 0)
            writer.tag(1, WireType.Varint).uint32(message.result);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message message.LastCycleResult
 */
export const LastCycleResult = new LastCycleResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExtendedColorZone$Type extends MessageType<ExtendedColorZone> {
    constructor() {
        super("message.ExtendedColorZone", [
            { no: 1, name: "zones_count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "zone_index", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "colors_count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "colors", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HSBK }
        ]);
    }
    create(value?: PartialMessage<ExtendedColorZone>): ExtendedColorZone {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.zonesCount = 0;
        message.zoneIndex = 0;
        message.colorsCount = 0;
        message.colors = [];
        if (value !== undefined)
            reflectionMergePartial<ExtendedColorZone>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExtendedColorZone): ExtendedColorZone {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 zones_count */ 1:
                    message.zonesCount = reader.uint32();
                    break;
                case /* uint32 zone_index */ 2:
                    message.zoneIndex = reader.uint32();
                    break;
                case /* uint32 colors_count */ 3:
                    message.colorsCount = reader.uint32();
                    break;
                case /* repeated message.HSBK colors */ 4:
                    message.colors.push(HSBK.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExtendedColorZone, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 zones_count = 1; */
        if (message.zonesCount !== 0)
            writer.tag(1, WireType.Varint).uint32(message.zonesCount);
        /* uint32 zone_index = 2; */
        if (message.zoneIndex !== 0)
            writer.tag(2, WireType.Varint).uint32(message.zoneIndex);
        /* uint32 colors_count = 3; */
        if (message.colorsCount !== 0)
            writer.tag(3, WireType.Varint).uint32(message.colorsCount);
        /* repeated message.HSBK colors = 4; */
        for (let i = 0; i < message.colors.length; i++)
            HSBK.internalBinaryWrite(message.colors[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message message.ExtendedColorZone
 */
export const ExtendedColorZone = new ExtendedColorZone$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Relay$Type extends MessageType<Relay> {
    constructor() {
        super("message.Relay", [
            { no: 1, name: "r_power", kind: "message", T: () => RPower }
        ]);
    }
    create(value?: PartialMessage<Relay>): Relay {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Relay>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Relay): Relay {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* message.RPower r_power */ 1:
                    message.rPower = RPower.internalBinaryRead(reader, reader.uint32(), options, message.rPower);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Relay, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* message.RPower r_power = 1; */
        if (message.rPower)
            RPower.internalBinaryWrite(message.rPower, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message message.Relay
 */
export const Relay = new Relay$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RPower$Type extends MessageType<RPower> {
    constructor() {
        super("message.RPower", [
            { no: 1, name: "relay_index", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "level", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<RPower>): RPower {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.relayIndex = 0;
        message.level = 0;
        if (value !== undefined)
            reflectionMergePartial<RPower>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RPower): RPower {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 relay_index */ 1:
                    message.relayIndex = reader.uint32();
                    break;
                case /* uint32 level */ 2:
                    message.level = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RPower, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 relay_index = 1; */
        if (message.relayIndex !== 0)
            writer.tag(1, WireType.Varint).uint32(message.relayIndex);
        /* uint32 level = 2; */
        if (message.level !== 0)
            writer.tag(2, WireType.Varint).uint32(message.level);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message message.RPower
 */
export const RPower = new RPower$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Tile$Type extends MessageType<Tile> {
    constructor() {
        super("message.Tile", [
            { no: 1, name: "device_chain", kind: "message", T: () => DeviceChain },
            { no: 2, name: "tile_64", kind: "message", T: () => Tile64 },
            { no: 3, name: "tile_effect", kind: "message", T: () => TileEffect },
            { no: 4, name: "sensor_ambient_light", kind: "message", T: () => SensorAmbientLight }
        ]);
    }
    create(value?: PartialMessage<Tile>): Tile {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Tile>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Tile): Tile {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* message.DeviceChain device_chain */ 1:
                    message.deviceChain = DeviceChain.internalBinaryRead(reader, reader.uint32(), options, message.deviceChain);
                    break;
                case /* message.Tile64 tile_64 */ 2:
                    message.tile64 = Tile64.internalBinaryRead(reader, reader.uint32(), options, message.tile64);
                    break;
                case /* message.TileEffect tile_effect */ 3:
                    message.tileEffect = TileEffect.internalBinaryRead(reader, reader.uint32(), options, message.tileEffect);
                    break;
                case /* message.SensorAmbientLight sensor_ambient_light */ 4:
                    message.sensorAmbientLight = SensorAmbientLight.internalBinaryRead(reader, reader.uint32(), options, message.sensorAmbientLight);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Tile, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* message.DeviceChain device_chain = 1; */
        if (message.deviceChain)
            DeviceChain.internalBinaryWrite(message.deviceChain, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* message.Tile64 tile_64 = 2; */
        if (message.tile64)
            Tile64.internalBinaryWrite(message.tile64, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* message.TileEffect tile_effect = 3; */
        if (message.tileEffect)
            TileEffect.internalBinaryWrite(message.tileEffect, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* message.SensorAmbientLight sensor_ambient_light = 4; */
        if (message.sensorAmbientLight)
            SensorAmbientLight.internalBinaryWrite(message.sensorAmbientLight, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message message.Tile
 */
export const Tile = new Tile$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeviceChain$Type extends MessageType<DeviceChain> {
    constructor() {
        super("message.DeviceChain", [
            { no: 1, name: "start_index", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "tile_devices", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => TileDevices },
            { no: 3, name: "tile_devices_count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<DeviceChain>): DeviceChain {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.startIndex = 0;
        message.tileDevices = [];
        message.tileDevicesCount = 0;
        if (value !== undefined)
            reflectionMergePartial<DeviceChain>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeviceChain): DeviceChain {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 start_index */ 1:
                    message.startIndex = reader.uint32();
                    break;
                case /* repeated message.TileDevices tile_devices */ 2:
                    message.tileDevices.push(TileDevices.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint32 tile_devices_count */ 3:
                    message.tileDevicesCount = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeviceChain, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 start_index = 1; */
        if (message.startIndex !== 0)
            writer.tag(1, WireType.Varint).uint32(message.startIndex);
        /* repeated message.TileDevices tile_devices = 2; */
        for (let i = 0; i < message.tileDevices.length; i++)
            TileDevices.internalBinaryWrite(message.tileDevices[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* uint32 tile_devices_count = 3; */
        if (message.tileDevicesCount !== 0)
            writer.tag(3, WireType.Varint).uint32(message.tileDevicesCount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message message.DeviceChain
 */
export const DeviceChain = new DeviceChain$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TileDevices$Type extends MessageType<TileDevices> {
    constructor() {
        super("message.TileDevices", [
            { no: 1, name: "accel_meas_x", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "accel_meas_y", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "accel_meas_z", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "reserved2", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "user_x", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "user_y", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "width", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "height", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "reserved7", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "device_version_vendor", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "device_version_product", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "reserved4", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "firmware_build", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 14, name: "reserved8", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "firmware_version_minor", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 16, name: "firmware_version_major", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 17, name: "reserved10", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<TileDevices>): TileDevices {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.accelMeasX = 0;
        message.accelMeasY = 0;
        message.accelMeasZ = 0;
        message.reserved2 = [];
        message.userX = 0;
        message.userY = 0;
        message.width = 0;
        message.height = 0;
        message.reserved7 = [];
        message.deviceVersionVendor = 0;
        message.deviceVersionProduct = 0;
        message.reserved4 = [];
        message.firmwareBuild = 0n;
        message.reserved8 = [];
        message.firmwareVersionMinor = 0;
        message.firmwareVersionMajor = 0;
        message.reserved10 = [];
        if (value !== undefined)
            reflectionMergePartial<TileDevices>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TileDevices): TileDevices {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 accel_meas_x */ 1:
                    message.accelMeasX = reader.uint32();
                    break;
                case /* uint32 accel_meas_y */ 2:
                    message.accelMeasY = reader.uint32();
                    break;
                case /* uint32 accel_meas_z */ 3:
                    message.accelMeasZ = reader.uint32();
                    break;
                case /* repeated uint32 reserved2 */ 4:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.reserved2.push(reader.uint32());
                    else
                        message.reserved2.push(reader.uint32());
                    break;
                case /* uint32 user_x */ 5:
                    message.userX = reader.uint32();
                    break;
                case /* uint32 user_y */ 6:
                    message.userY = reader.uint32();
                    break;
                case /* uint32 width */ 7:
                    message.width = reader.uint32();
                    break;
                case /* uint32 height */ 8:
                    message.height = reader.uint32();
                    break;
                case /* repeated uint32 reserved7 */ 9:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.reserved7.push(reader.uint32());
                    else
                        message.reserved7.push(reader.uint32());
                    break;
                case /* uint32 device_version_vendor */ 10:
                    message.deviceVersionVendor = reader.uint32();
                    break;
                case /* uint32 device_version_product */ 11:
                    message.deviceVersionProduct = reader.uint32();
                    break;
                case /* repeated uint32 reserved4 */ 12:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.reserved4.push(reader.uint32());
                    else
                        message.reserved4.push(reader.uint32());
                    break;
                case /* uint64 firmware_build */ 13:
                    message.firmwareBuild = reader.uint64().toBigInt();
                    break;
                case /* repeated uint32 reserved8 */ 14:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.reserved8.push(reader.uint32());
                    else
                        message.reserved8.push(reader.uint32());
                    break;
                case /* uint32 firmware_version_minor */ 15:
                    message.firmwareVersionMinor = reader.uint32();
                    break;
                case /* uint32 firmware_version_major */ 16:
                    message.firmwareVersionMajor = reader.uint32();
                    break;
                case /* repeated uint32 reserved10 */ 17:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.reserved10.push(reader.uint32());
                    else
                        message.reserved10.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TileDevices, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 accel_meas_x = 1; */
        if (message.accelMeasX !== 0)
            writer.tag(1, WireType.Varint).uint32(message.accelMeasX);
        /* uint32 accel_meas_y = 2; */
        if (message.accelMeasY !== 0)
            writer.tag(2, WireType.Varint).uint32(message.accelMeasY);
        /* uint32 accel_meas_z = 3; */
        if (message.accelMeasZ !== 0)
            writer.tag(3, WireType.Varint).uint32(message.accelMeasZ);
        /* repeated uint32 reserved2 = 4; */
        if (message.reserved2.length) {
            writer.tag(4, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.reserved2.length; i++)
                writer.uint32(message.reserved2[i]);
            writer.join();
        }
        /* uint32 user_x = 5; */
        if (message.userX !== 0)
            writer.tag(5, WireType.Varint).uint32(message.userX);
        /* uint32 user_y = 6; */
        if (message.userY !== 0)
            writer.tag(6, WireType.Varint).uint32(message.userY);
        /* uint32 width = 7; */
        if (message.width !== 0)
            writer.tag(7, WireType.Varint).uint32(message.width);
        /* uint32 height = 8; */
        if (message.height !== 0)
            writer.tag(8, WireType.Varint).uint32(message.height);
        /* repeated uint32 reserved7 = 9; */
        if (message.reserved7.length) {
            writer.tag(9, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.reserved7.length; i++)
                writer.uint32(message.reserved7[i]);
            writer.join();
        }
        /* uint32 device_version_vendor = 10; */
        if (message.deviceVersionVendor !== 0)
            writer.tag(10, WireType.Varint).uint32(message.deviceVersionVendor);
        /* uint32 device_version_product = 11; */
        if (message.deviceVersionProduct !== 0)
            writer.tag(11, WireType.Varint).uint32(message.deviceVersionProduct);
        /* repeated uint32 reserved4 = 12; */
        if (message.reserved4.length) {
            writer.tag(12, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.reserved4.length; i++)
                writer.uint32(message.reserved4[i]);
            writer.join();
        }
        /* uint64 firmware_build = 13; */
        if (message.firmwareBuild !== 0n)
            writer.tag(13, WireType.Varint).uint64(message.firmwareBuild);
        /* repeated uint32 reserved8 = 14; */
        if (message.reserved8.length) {
            writer.tag(14, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.reserved8.length; i++)
                writer.uint32(message.reserved8[i]);
            writer.join();
        }
        /* uint32 firmware_version_minor = 15; */
        if (message.firmwareVersionMinor !== 0)
            writer.tag(15, WireType.Varint).uint32(message.firmwareVersionMinor);
        /* uint32 firmware_version_major = 16; */
        if (message.firmwareVersionMajor !== 0)
            writer.tag(16, WireType.Varint).uint32(message.firmwareVersionMajor);
        /* repeated uint32 reserved10 = 17; */
        if (message.reserved10.length) {
            writer.tag(17, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.reserved10.length; i++)
                writer.uint32(message.reserved10[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message message.TileDevices
 */
export const TileDevices = new TileDevices$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Tile64$Type extends MessageType<Tile64> {
    constructor() {
        super("message.Tile64", [
            { no: 1, name: "tile_index", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "x", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "y", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "width", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "colors", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HSBK }
        ]);
    }
    create(value?: PartialMessage<Tile64>): Tile64 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tileIndex = 0;
        message.x = 0;
        message.y = 0;
        message.width = 0;
        message.colors = [];
        if (value !== undefined)
            reflectionMergePartial<Tile64>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Tile64): Tile64 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 tile_index */ 1:
                    message.tileIndex = reader.uint32();
                    break;
                case /* uint32 x */ 2:
                    message.x = reader.uint32();
                    break;
                case /* uint32 y */ 3:
                    message.y = reader.uint32();
                    break;
                case /* uint32 width */ 4:
                    message.width = reader.uint32();
                    break;
                case /* repeated message.HSBK colors */ 5:
                    message.colors.push(HSBK.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Tile64, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 tile_index = 1; */
        if (message.tileIndex !== 0)
            writer.tag(1, WireType.Varint).uint32(message.tileIndex);
        /* uint32 x = 2; */
        if (message.x !== 0)
            writer.tag(2, WireType.Varint).uint32(message.x);
        /* uint32 y = 3; */
        if (message.y !== 0)
            writer.tag(3, WireType.Varint).uint32(message.y);
        /* uint32 width = 4; */
        if (message.width !== 0)
            writer.tag(4, WireType.Varint).uint32(message.width);
        /* repeated message.HSBK colors = 5; */
        for (let i = 0; i < message.colors.length; i++)
            HSBK.internalBinaryWrite(message.colors[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message message.Tile64
 */
export const Tile64 = new Tile64$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TileEffect$Type extends MessageType<TileEffect> {
    constructor() {
        super("message.TileEffect", [
            { no: 1, name: "instanceid", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "speed", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "duration", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "parameters", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "palette_count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "palette", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HSBK }
        ]);
    }
    create(value?: PartialMessage<TileEffect>): TileEffect {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.instanceid = 0;
        message.type = 0;
        message.speed = 0;
        message.duration = 0n;
        message.parameters = [];
        message.paletteCount = 0;
        message.palette = [];
        if (value !== undefined)
            reflectionMergePartial<TileEffect>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TileEffect): TileEffect {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 instanceid */ 1:
                    message.instanceid = reader.uint32();
                    break;
                case /* uint32 type */ 2:
                    message.type = reader.uint32();
                    break;
                case /* uint32 speed */ 3:
                    message.speed = reader.uint32();
                    break;
                case /* uint64 duration */ 4:
                    message.duration = reader.uint64().toBigInt();
                    break;
                case /* repeated uint32 parameters */ 5:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.parameters.push(reader.uint32());
                    else
                        message.parameters.push(reader.uint32());
                    break;
                case /* uint32 palette_count */ 6:
                    message.paletteCount = reader.uint32();
                    break;
                case /* repeated message.HSBK palette */ 7:
                    message.palette.push(HSBK.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TileEffect, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 instanceid = 1; */
        if (message.instanceid !== 0)
            writer.tag(1, WireType.Varint).uint32(message.instanceid);
        /* uint32 type = 2; */
        if (message.type !== 0)
            writer.tag(2, WireType.Varint).uint32(message.type);
        /* uint32 speed = 3; */
        if (message.speed !== 0)
            writer.tag(3, WireType.Varint).uint32(message.speed);
        /* uint64 duration = 4; */
        if (message.duration !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.duration);
        /* repeated uint32 parameters = 5; */
        if (message.parameters.length) {
            writer.tag(5, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.parameters.length; i++)
                writer.uint32(message.parameters[i]);
            writer.join();
        }
        /* uint32 palette_count = 6; */
        if (message.paletteCount !== 0)
            writer.tag(6, WireType.Varint).uint32(message.paletteCount);
        /* repeated message.HSBK palette = 7; */
        for (let i = 0; i < message.palette.length; i++)
            HSBK.internalBinaryWrite(message.palette[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message message.TileEffect
 */
export const TileEffect = new TileEffect$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SensorAmbientLight$Type extends MessageType<SensorAmbientLight> {
    constructor() {
        super("message.SensorAmbientLight", [
            { no: 1, name: "lux", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<SensorAmbientLight>): SensorAmbientLight {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.lux = [];
        if (value !== undefined)
            reflectionMergePartial<SensorAmbientLight>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SensorAmbientLight): SensorAmbientLight {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint32 lux */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.lux.push(reader.uint32());
                    else
                        message.lux.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SensorAmbientLight, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated uint32 lux = 1; */
        if (message.lux.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.lux.length; i++)
                writer.uint32(message.lux[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message message.SensorAmbientLight
 */
export const SensorAmbientLight = new SensorAmbientLight$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDevicesRequest$Type extends MessageType<GetDevicesRequest> {
    constructor() {
        super("message.GetDevicesRequest", []);
    }
    create(value?: PartialMessage<GetDevicesRequest>): GetDevicesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetDevicesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDevicesRequest): GetDevicesRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetDevicesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message message.GetDevicesRequest
 */
export const GetDevicesRequest = new GetDevicesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDevicesResponse$Type extends MessageType<GetDevicesResponse> {
    constructor() {
        super("message.GetDevicesResponse", [
            { no: 1, name: "locations", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => LocationMap } }
        ]);
    }
    create(value?: PartialMessage<GetDevicesResponse>): GetDevicesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.locations = {};
        if (value !== undefined)
            reflectionMergePartial<GetDevicesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDevicesResponse): GetDevicesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, message.LocationMap> locations */ 1:
                    this.binaryReadMap1(message.locations, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: GetDevicesResponse["locations"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GetDevicesResponse["locations"] | undefined, val: GetDevicesResponse["locations"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = LocationMap.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field message.GetDevicesResponse.locations");
            }
        }
        map[key ?? ""] = val ?? LocationMap.create();
    }
    internalBinaryWrite(message: GetDevicesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, message.LocationMap> locations = 1; */
        for (let k of globalThis.Object.keys(message.locations)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            LocationMap.internalBinaryWrite(message.locations[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message message.GetDevicesResponse
 */
export const GetDevicesResponse = new GetDevicesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetLocationLabelRequest$Type extends MessageType<SetLocationLabelRequest> {
    constructor() {
        super("message.SetLocationLabelRequest", [
            { no: 1, name: "locationID", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "newLabel", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SetLocationLabelRequest>): SetLocationLabelRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.locationID = "";
        message.newLabel = "";
        if (value !== undefined)
            reflectionMergePartial<SetLocationLabelRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetLocationLabelRequest): SetLocationLabelRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string locationID */ 1:
                    message.locationID = reader.string();
                    break;
                case /* string newLabel */ 2:
                    message.newLabel = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetLocationLabelRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string locationID = 1; */
        if (message.locationID !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.locationID);
        /* string newLabel = 2; */
        if (message.newLabel !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.newLabel);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message message.SetLocationLabelRequest
 */
export const SetLocationLabelRequest = new SetLocationLabelRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetLocationLabelResponse$Type extends MessageType<SetLocationLabelResponse> {
    constructor() {
        super("message.SetLocationLabelResponse", []);
    }
    create(value?: PartialMessage<SetLocationLabelResponse>): SetLocationLabelResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SetLocationLabelResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetLocationLabelResponse): SetLocationLabelResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SetLocationLabelResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message message.SetLocationLabelResponse
 */
export const SetLocationLabelResponse = new SetLocationLabelResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetGroupLabelRequest$Type extends MessageType<SetGroupLabelRequest> {
    constructor() {
        super("message.SetGroupLabelRequest", [
            { no: 1, name: "groupID", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "newLabel", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SetGroupLabelRequest>): SetGroupLabelRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.groupID = "";
        message.newLabel = "";
        if (value !== undefined)
            reflectionMergePartial<SetGroupLabelRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetGroupLabelRequest): SetGroupLabelRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string groupID */ 1:
                    message.groupID = reader.string();
                    break;
                case /* string newLabel */ 2:
                    message.newLabel = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetGroupLabelRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string groupID = 1; */
        if (message.groupID !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.groupID);
        /* string newLabel = 2; */
        if (message.newLabel !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.newLabel);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message message.SetGroupLabelRequest
 */
export const SetGroupLabelRequest = new SetGroupLabelRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetGroupLabelResponse$Type extends MessageType<SetGroupLabelResponse> {
    constructor() {
        super("message.SetGroupLabelResponse", []);
    }
    create(value?: PartialMessage<SetGroupLabelResponse>): SetGroupLabelResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SetGroupLabelResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetGroupLabelResponse): SetGroupLabelResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SetGroupLabelResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message message.SetGroupLabelResponse
 */
export const SetGroupLabelResponse = new SetGroupLabelResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetDeviceLabelRequest$Type extends MessageType<SetDeviceLabelRequest> {
    constructor() {
        super("message.SetDeviceLabelRequest", [
            { no: 1, name: "deviceID", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "newLabel", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SetDeviceLabelRequest>): SetDeviceLabelRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.deviceID = 0n;
        message.newLabel = "";
        if (value !== undefined)
            reflectionMergePartial<SetDeviceLabelRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetDeviceLabelRequest): SetDeviceLabelRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 deviceID */ 1:
                    message.deviceID = reader.uint64().toBigInt();
                    break;
                case /* string newLabel */ 2:
                    message.newLabel = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetDeviceLabelRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 deviceID = 1; */
        if (message.deviceID !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.deviceID);
        /* string newLabel = 2; */
        if (message.newLabel !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.newLabel);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message message.SetDeviceLabelRequest
 */
export const SetDeviceLabelRequest = new SetDeviceLabelRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetDeviceLabelResponse$Type extends MessageType<SetDeviceLabelResponse> {
    constructor() {
        super("message.SetDeviceLabelResponse", []);
    }
    create(value?: PartialMessage<SetDeviceLabelResponse>): SetDeviceLabelResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SetDeviceLabelResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetDeviceLabelResponse): SetDeviceLabelResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SetDeviceLabelResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message message.SetDeviceLabelResponse
 */
export const SetDeviceLabelResponse = new SetDeviceLabelResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetColorRequest$Type extends MessageType<SetColorRequest> {
    constructor() {
        super("message.SetColorRequest", [
            { no: 1, name: "colors", kind: "map", K: 4 /*ScalarType.UINT64*/, V: { kind: "message", T: () => HSBK } }
        ]);
    }
    create(value?: PartialMessage<SetColorRequest>): SetColorRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.colors = {};
        if (value !== undefined)
            reflectionMergePartial<SetColorRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetColorRequest): SetColorRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<uint64, message.HSBK> colors */ 1:
                    this.binaryReadMap1(message.colors, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: SetColorRequest["colors"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof SetColorRequest["colors"] | undefined, val: SetColorRequest["colors"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint64().toString();
                    break;
                case 2:
                    val = HSBK.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field message.SetColorRequest.colors");
            }
        }
        map[key ?? "0"] = val ?? HSBK.create();
    }
    internalBinaryWrite(message: SetColorRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<uint64, message.HSBK> colors = 1; */
        for (let k of globalThis.Object.keys(message.colors)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint64(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            HSBK.internalBinaryWrite(message.colors[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message message.SetColorRequest
 */
export const SetColorRequest = new SetColorRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetColorResponse$Type extends MessageType<SetColorResponse> {
    constructor() {
        super("message.SetColorResponse", []);
    }
    create(value?: PartialMessage<SetColorResponse>): SetColorResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SetColorResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetColorResponse): SetColorResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SetColorResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message message.SetColorResponse
 */
export const SetColorResponse = new SetColorResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetPowerRequest$Type extends MessageType<SetPowerRequest> {
    constructor() {
        super("message.SetPowerRequest", [
            { no: 1, name: "powers", kind: "map", K: 4 /*ScalarType.UINT64*/, V: { kind: "scalar", T: 8 /*ScalarType.BOOL*/ } }
        ]);
    }
    create(value?: PartialMessage<SetPowerRequest>): SetPowerRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.powers = {};
        if (value !== undefined)
            reflectionMergePartial<SetPowerRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetPowerRequest): SetPowerRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<uint64, bool> powers */ 1:
                    this.binaryReadMap1(message.powers, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: SetPowerRequest["powers"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof SetPowerRequest["powers"] | undefined, val: SetPowerRequest["powers"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint64().toString();
                    break;
                case 2:
                    val = reader.bool();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field message.SetPowerRequest.powers");
            }
        }
        map[key ?? "0"] = val ?? false;
    }
    internalBinaryWrite(message: SetPowerRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<uint64, bool> powers = 1; */
        for (let k of globalThis.Object.keys(message.powers))
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint64(k).tag(2, WireType.Varint).bool(message.powers[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message message.SetPowerRequest
 */
export const SetPowerRequest = new SetPowerRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetPowerResponse$Type extends MessageType<SetPowerResponse> {
    constructor() {
        super("message.SetPowerResponse", []);
    }
    create(value?: PartialMessage<SetPowerResponse>): SetPowerResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SetPowerResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetPowerResponse): SetPowerResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SetPowerResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message message.SetPowerResponse
 */
export const SetPowerResponse = new SetPowerResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StrobeRequest$Type extends MessageType<StrobeRequest> {
    constructor() {
        super("message.StrobeRequest", [
            { no: 1, name: "deviceIDs", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "speed", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "turnOn", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<StrobeRequest>): StrobeRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.deviceIDs = [];
        message.speed = 0;
        message.turnOn = false;
        if (value !== undefined)
            reflectionMergePartial<StrobeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StrobeRequest): StrobeRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint64 deviceIDs */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.deviceIDs.push(reader.uint64().toBigInt());
                    else
                        message.deviceIDs.push(reader.uint64().toBigInt());
                    break;
                case /* float speed */ 2:
                    message.speed = reader.float();
                    break;
                case /* bool turnOn */ 3:
                    message.turnOn = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StrobeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated uint64 deviceIDs = 1; */
        if (message.deviceIDs.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.deviceIDs.length; i++)
                writer.uint64(message.deviceIDs[i]);
            writer.join();
        }
        /* float speed = 2; */
        if (message.speed !== 0)
            writer.tag(2, WireType.Bit32).float(message.speed);
        /* bool turnOn = 3; */
        if (message.turnOn !== false)
            writer.tag(3, WireType.Varint).bool(message.turnOn);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message message.StrobeRequest
 */
export const StrobeRequest = new StrobeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StrobeResponse$Type extends MessageType<StrobeResponse> {
    constructor() {
        super("message.StrobeResponse", []);
    }
    create(value?: PartialMessage<StrobeResponse>): StrobeResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<StrobeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StrobeResponse): StrobeResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: StrobeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message message.StrobeResponse
 */
export const StrobeResponse = new StrobeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ColorCycleRequest$Type extends MessageType<ColorCycleRequest> {
    constructor() {
        super("message.ColorCycleRequest", [
            { no: 1, name: "deviceIDs", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "speed", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "turnOn", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ColorCycleRequest>): ColorCycleRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.deviceIDs = [];
        message.speed = 0;
        message.turnOn = false;
        if (value !== undefined)
            reflectionMergePartial<ColorCycleRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ColorCycleRequest): ColorCycleRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint64 deviceIDs */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.deviceIDs.push(reader.uint64().toBigInt());
                    else
                        message.deviceIDs.push(reader.uint64().toBigInt());
                    break;
                case /* float speed */ 2:
                    message.speed = reader.float();
                    break;
                case /* bool turnOn */ 3:
                    message.turnOn = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ColorCycleRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated uint64 deviceIDs = 1; */
        if (message.deviceIDs.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.deviceIDs.length; i++)
                writer.uint64(message.deviceIDs[i]);
            writer.join();
        }
        /* float speed = 2; */
        if (message.speed !== 0)
            writer.tag(2, WireType.Bit32).float(message.speed);
        /* bool turnOn = 3; */
        if (message.turnOn !== false)
            writer.tag(3, WireType.Varint).bool(message.turnOn);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message message.ColorCycleRequest
 */
export const ColorCycleRequest = new ColorCycleRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ColorCycleResponse$Type extends MessageType<ColorCycleResponse> {
    constructor() {
        super("message.ColorCycleResponse", []);
    }
    create(value?: PartialMessage<ColorCycleResponse>): ColorCycleResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ColorCycleResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ColorCycleResponse): ColorCycleResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: ColorCycleResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message message.ColorCycleResponse
 */
export const ColorCycleResponse = new ColorCycleResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TwinkleRequest$Type extends MessageType<TwinkleRequest> {
    constructor() {
        super("message.TwinkleRequest", [
            { no: 1, name: "deviceColors", kind: "map", K: 4 /*ScalarType.UINT64*/, V: { kind: "message", T: () => HSBK } },
            { no: 2, name: "speed", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "intensity", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "turnOn", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<TwinkleRequest>): TwinkleRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.deviceColors = {};
        message.speed = 0;
        message.intensity = 0;
        message.turnOn = false;
        if (value !== undefined)
            reflectionMergePartial<TwinkleRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TwinkleRequest): TwinkleRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<uint64, message.HSBK> deviceColors */ 1:
                    this.binaryReadMap1(message.deviceColors, reader, options);
                    break;
                case /* float speed */ 2:
                    message.speed = reader.float();
                    break;
                case /* float intensity */ 3:
                    message.intensity = reader.float();
                    break;
                case /* bool turnOn */ 4:
                    message.turnOn = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: TwinkleRequest["deviceColors"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TwinkleRequest["deviceColors"] | undefined, val: TwinkleRequest["deviceColors"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint64().toString();
                    break;
                case 2:
                    val = HSBK.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field message.TwinkleRequest.deviceColors");
            }
        }
        map[key ?? "0"] = val ?? HSBK.create();
    }
    internalBinaryWrite(message: TwinkleRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<uint64, message.HSBK> deviceColors = 1; */
        for (let k of globalThis.Object.keys(message.deviceColors)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint64(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            HSBK.internalBinaryWrite(message.deviceColors[k], writer, options);
            writer.join().join();
        }
        /* float speed = 2; */
        if (message.speed !== 0)
            writer.tag(2, WireType.Bit32).float(message.speed);
        /* float intensity = 3; */
        if (message.intensity !== 0)
            writer.tag(3, WireType.Bit32).float(message.intensity);
        /* bool turnOn = 4; */
        if (message.turnOn !== false)
            writer.tag(4, WireType.Varint).bool(message.turnOn);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message message.TwinkleRequest
 */
export const TwinkleRequest = new TwinkleRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TwinkleResponse$Type extends MessageType<TwinkleResponse> {
    constructor() {
        super("message.TwinkleResponse", []);
    }
    create(value?: PartialMessage<TwinkleResponse>): TwinkleResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TwinkleResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TwinkleResponse): TwinkleResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: TwinkleResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message message.TwinkleResponse
 */
export const TwinkleResponse = new TwinkleResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VisualizerRequest$Type extends MessageType<VisualizerRequest> {
    constructor() {
        super("message.VisualizerRequest", [
            { no: 1, name: "deviceIDs", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "variation", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "turnOn", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<VisualizerRequest>): VisualizerRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.deviceIDs = [];
        message.variation = 0;
        message.turnOn = false;
        if (value !== undefined)
            reflectionMergePartial<VisualizerRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VisualizerRequest): VisualizerRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint64 deviceIDs */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.deviceIDs.push(reader.uint64().toBigInt());
                    else
                        message.deviceIDs.push(reader.uint64().toBigInt());
                    break;
                case /* float variation */ 2:
                    message.variation = reader.float();
                    break;
                case /* bool turnOn */ 3:
                    message.turnOn = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VisualizerRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated uint64 deviceIDs = 1; */
        if (message.deviceIDs.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.deviceIDs.length; i++)
                writer.uint64(message.deviceIDs[i]);
            writer.join();
        }
        /* float variation = 2; */
        if (message.variation !== 0)
            writer.tag(2, WireType.Bit32).float(message.variation);
        /* bool turnOn = 3; */
        if (message.turnOn !== false)
            writer.tag(3, WireType.Varint).bool(message.turnOn);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message message.VisualizerRequest
 */
export const VisualizerRequest = new VisualizerRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VisualizerResponse$Type extends MessageType<VisualizerResponse> {
    constructor() {
        super("message.VisualizerResponse", []);
    }
    create(value?: PartialMessage<VisualizerResponse>): VisualizerResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<VisualizerResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VisualizerResponse): VisualizerResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: VisualizerResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message message.VisualizerResponse
 */
export const VisualizerResponse = new VisualizerResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TheaterRequest$Type extends MessageType<TheaterRequest> {
    constructor() {
        super("message.TheaterRequest", [
            { no: 1, name: "deviceIDs", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "turnOn", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "screen", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TheaterRequest>): TheaterRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.deviceIDs = [];
        message.turnOn = false;
        message.screen = 0;
        if (value !== undefined)
            reflectionMergePartial<TheaterRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TheaterRequest): TheaterRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint64 deviceIDs */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.deviceIDs.push(reader.uint64().toBigInt());
                    else
                        message.deviceIDs.push(reader.uint64().toBigInt());
                    break;
                case /* bool turnOn */ 2:
                    message.turnOn = reader.bool();
                    break;
                case /* int32 screen */ 3:
                    message.screen = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TheaterRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated uint64 deviceIDs = 1; */
        if (message.deviceIDs.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.deviceIDs.length; i++)
                writer.uint64(message.deviceIDs[i]);
            writer.join();
        }
        /* bool turnOn = 2; */
        if (message.turnOn !== false)
            writer.tag(2, WireType.Varint).bool(message.turnOn);
        /* int32 screen = 3; */
        if (message.screen !== 0)
            writer.tag(3, WireType.Varint).int32(message.screen);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message message.TheaterRequest
 */
export const TheaterRequest = new TheaterRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TheaterResponse$Type extends MessageType<TheaterResponse> {
    constructor() {
        super("message.TheaterResponse", []);
    }
    create(value?: PartialMessage<TheaterResponse>): TheaterResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TheaterResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TheaterResponse): TheaterResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: TheaterResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message message.TheaterResponse
 */
export const TheaterResponse = new TheaterResponse$Type();
/**
 * @generated ServiceType for protobuf service message.DeviceService
 */
export const DeviceService = new ServiceType("message.DeviceService", [
    { name: "GetDevices", options: {}, I: GetDevicesRequest, O: GetDevicesResponse },
    { name: "SetLocationLabel", options: {}, I: SetLocationLabelRequest, O: SetLocationLabelResponse },
    { name: "SetGroupLabel", options: {}, I: SetGroupLabelRequest, O: SetGroupLabelResponse },
    { name: "SetDeviceLabel", options: {}, I: SetDeviceLabelRequest, O: SetDeviceLabelResponse },
    { name: "SetColor", options: {}, I: SetColorRequest, O: SetColorResponse },
    { name: "SetPower", options: {}, I: SetPowerRequest, O: SetPowerResponse },
    { name: "Strobe", options: {}, I: StrobeRequest, O: StrobeResponse },
    { name: "ColorCycle", options: {}, I: ColorCycleRequest, O: ColorCycleResponse },
    { name: "Twinkle", options: {}, I: TwinkleRequest, O: TwinkleResponse },
    { name: "Visualizer", options: {}, I: VisualizerRequest, O: VisualizerResponse },
    { name: "Theater", options: {}, I: TheaterRequest, O: TheaterResponse }
]);
